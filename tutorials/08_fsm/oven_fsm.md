One example of a finite state machine (FSM) in SystemVerilog is a digital controller for a microwave oven. The FSM would have states such as "standby," "cooking," "paused," and "completed," and would transition between these states based on inputs such as button presses and sensor readings. For example, when the "start" button is pressed, the FSM would transition from "standby" to "cooking," and when the cooking time has expired, it would transition from "cooking" to "completed."

The state diagram would have several states, including:

- Standby: The initial state, where the oven is idle and waiting for user input.
- Cooking: The state in which the oven is actively cooking the food.
- Paused: The state in which cooking is temporarily suspended, but can be resumed.
- Completed: The state in which the oven has finished cooking the food.

Transitions between states would be triggered by events such as button presses or sensor readings. For example, when the "start" button is pressed, the FSM would transition from "standby" to "cooking." When the cooking time has expired, it would transition from "cooking" to "completed." If the "pause" button is pressed while in the "cooking" state, the FSM would transition to "paused." And if the "resume" button is pressed while in the "paused" state, the FSM would transition back to "cooking."

It's important to note that depending on the design, there could be multiple transition paths between some states and this diagram is a simple example and can be more complex and detailed according to the oven's specifications and requirements.

In SystemVerilog, a finite state machine (FSM) can be implemented using a combination of a state register, next state logic, and output logic.

1. Define the states of the FSM as enumerated types:

```sv
typedef enum {STANDBY, COOKING, PAUSED, COMPLETED} states;
```

2. Create a state register to store the current state of the FSM:

```sv
reg [1:0] state;
```

3. Create next state logic to determine the next state based on the current state and inputs:

```sv
always_comb
begin
    case (state)
        states.STANDBY:
            if (start_button)
                next_state = states.COOKING;
            else
                next_state = states.STANDBY;
        states.COOKING:
            if (stop_button)
                next_state = states.STANDBY;
            else if (pause_button)
                next_state = states.PAUSED;
            else if (time_elapsed)
                next_state = states.COMPLETED;
            else
                next_state = states.COOKING;
        states.PAUSED:
            if (stop_button)
                next_state = states.STANDBY;
            else if (resume_button)
                next_state = states.COOKING;
            else
                next_state = states.PAUSED;
        states.COMPLETED:
            if (stop_button)
                next_state = states.STANDBY;
            else
                next_state = states.COMPLETED;
        default: next_state = states.STANDBY;
    endcase
end

```

4. Create output logic to determine the output signals based on the current state:

```sv
always_comb
begin
    case (state)
        states.STANDBY:
            oven_on = 0;
            display = "Standby";
        states.COOKING:
            oven_on = 1;
            display = "Cooking";
        states.PAUSED:
            oven_on = 0;
            display = "Paused";
        states.COMPLETED:
            oven_on = 0;
            display = "Completed";
    endcase
end
```

5. Update the state register in the next state logic:

```sv
always_ff
begin
    state <= next_state;
end
```

This is an example of how the FSM could be implemented in SystemVerilog, but it's important to note that there are many ways to implement a FSM and this is just one example. It's also important to consider the specific requirements and constraints of your design and to test the FSM thoroughly before integrating it into your system.

In the example I provided, the "time_elapsed" signal is a hypothetical input that is used to indicate that the cooking time has expired. It could be generated by a timer module or a counter module that counts down from the set cooking time. The exact implementation of the "time_elapsed" signal would depend on the specific requirements and constraints of the design.

It could be implemented as a variable that is incremented on each clock cycle in the cooking state and when it reaches to certain value that indicates the cooking time is over, the time_elapsed signal is set to 1 and the FSM transition to the completed state.

In this example, I assumed the time_elapsed signal is an input signal to the FSM, however, in practice it could be an internal signal generated by a timer/counter module or other logic within the design.

In the example I provided, the FSM and the internal counter for the "time_elapsed" signal would typically use the same clock signal (clk). This is because the FSM and the counter need to be synchronized and operate at the same rate.

However, it's important to ensure that the counter and the FSM are designed to operate correctly at the same clock frequency. If the counter is not fast enough, it may not be able to keep up with the FSM and the time_elapsed signal may not be accurate.

It's also important to take into account the reset behavior of the counter and the FSM, to make sure that the both are reset at the same time and in the correct order.

In addition, it's good to think about the future scalability of the design, because if the clock frequency is changed in the future, this may affect the counter's performance and it should be re-evaluated.

In summary, it's a good practice to use the same clock for the FSM and internal counter, but it's important to consider the clock frequency, reset behavior and scalability of the design when doing so.