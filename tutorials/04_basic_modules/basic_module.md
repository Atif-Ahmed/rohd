# Basic Module in ROHD

## Why we need to use ROHD Module

Congratulation on making this far! 

In this tutorial, we are going to dive in on the topic `Module`s. If you have prior experience with System Verilog, they are kind of the same `Module` that we are referring. Basically, `Module` will have inputs and outputs that connects them. 

The question is why do we need a module? We had seen in previous tutorials that we can survive or use ROHD without creating module right? Well, that is because we haven't go deep to simulator or system verilog code generation. But in a typical ROHD framework, you will need `Module` to unlock capability of `generateSynth()` or `Simulation()`. Therefore, it is good to learn about ROHD module to further increase the flexibility of the hardware design. We will be using a lot of `.build()` function in the later `Sequential` circuit.

To use module, you must follow some rules here:

1. All logic **within `Module`** must consume only inputs (`input` or `addInput`) to the Module either directly or indirectly.

2. Any logic **outside `Module`** must consume the signals only via outputs (`output` or `addOutput`) of Module

3. Logic must be defined **before** the call to `super.build()`, which always must be called at the end of the build() method if it is overidden.

# First Module (one input, one output, simple logic)

Let say an example of how to create a simple ROHD module. The example below shows the simple module created with one `input` and `output`. Notice that `addInput()` and `addOutput()` is used as mentioned previously to register for input and output ports. Another things to note this the Logic of the Module `output <= input` is included inside the constructor so that `build()` instruction will pick up the Logic during the execution process.

```dart
import 'package:rohd/rohd.dart';
import 'package:test/test.dart';

class SimpleModule extends Module {
  SimpleModule(Logic input) {
    // register input port
    input = addInput('input_1', input);

    // register output port
    var output = addOutput('out');

    // Logic of the Module
    output <= input;
  }
}

void main() async {
  final input = Const(1);
  final simModule = SimpleModule(input);
  await simModule.build();

  test('should return input value',
      () => expect(simModule.signals.first.value.toInt(), equals(1)));
}
```

It is legal to put logic within an override of the `build` function, but that forces users of your module to always call `build` before it will be functionally usable for simple simulation. If you put logic in `build()`, ensure you put the call to `super.build()` at the end of the method.

```dart
class SimpleModule extends Module {
  // Variables are now marked as global variables
  late Logic output1;
  late final Logic input1;

  SimpleModule(Logic in1) {
    // register input port
    input1 = addInput(name, in1);

    // register output port
    output1 = addOutput('out');
  }

  @override
  Future<void> build() async {
    // Move Logic to here instead
    output1 <= input1;

    await super.build();
  }
}
```

This would still work, but you have to really be careful.

Do note that the `build()` method returns a `Future<void>`, not just `void`. This is because the `build()` method is permitted to consume real wallclock time in some cases, for example for setting up cosimulation with another simulator. If you expect your build to consume wallclock time, make sure the Simulator is aware it needs to wait before proceeding.

That all about the basic of the module! :)

## Converting to System Verilog

Next, we can see how by extending your Logic to `Module` enable generation of system verilog code. 

```dart
void main() async {
  final input = Const(1);
  final simModule = SimpleModule(input);
  await simModule.build();

  // Print out system verilog code
  print(simModule.generateSynth());

  test('should return input value.',
      () => expect(simModule.signals.first.value.toInt(), equals(1)));

  // Add this to generate system verilog code
  test(
      'should generate system verilog code.',
      () =>
          expect(simModule.generateSynth(), contains('module SimpleModule(')));
}
```

The output of the print above will show:

```output
/**
 * Generated by ROHD - www.github.com/intel/rohd
 * Generation time: 2022-12-29 14:53:52.400586
 * ROHD Version: 0.4.1
 */

module SimpleModule(
input logic input_1,
output logic out
);
assign out = input_1;
endmodule : SimpleModule
```

Pretty cool huh? ROHD is smart enough to include only the important details to system verilog but ignore all the unit test stuff. :sunglasses:

### You have done pretty good job up until now? Can you try to change our full adder tutorial last time to ROHD Module?

## Composing modules within other modules

In this example, we will see how compose a module within another module using our old example - FullAdder. 

How your exercise? Is it work? Maybe some of you have achieve this, but ROHD can compose module within other module as well. As you notice in my `FullAdder` and `NBitAdder` class. The `FullAdder` Module class is compose in `FullAdder` class which make the for loop in `NBitAdder` to generate `FullAdder` programmatically.

```dart
import 'package:rohd/rohd.dart';
import 'package:test/test.dart';

class FullAdderResult {
  final sum = Logic(name: 'sum');
  final cOut = Logic(name: 'c_out');
}

class FullAdder extends Module {
  final fullAdderresult = FullAdderResult();

  // Constructor
  FullAdder({
    required Logic a,
    required Logic b,
    required Logic carryIn,
    super.name = 'full_adder',
  }) {
    // Declare Input Node
    a = addInput('a', a, width: a.width);
    b = addInput('b', b, width: b.width);
    carryIn = addInput('carry_in', carryIn, width: carryIn.width);

    // Declare Output Node
    final carryOut = addOutput('carry_out');
    final sum = addOutput('sum');

    final and1 = carryIn & (a ^ b);
    final and2 = b & a;

    // Use Combinational block
    Combinational([
      sum < (a ^ b) ^ carryIn,
      carryOut < and1 | and2,
    ]);

    fullAdderresult.sum <= output('sum');
    fullAdderresult.cOut <= output('carry_out');
  }

  FullAdderResult get fullAdderRes => fullAdderresult;
}

class NBitAdder extends Module {
  // Add Input and output port
  final sum = <Logic>[];
  Logic carry = Const(0);
  Logic a;
  Logic b;

  NBitAdder(this.a, this.b) {
    // Declare Input Node
    a = addInput('a', a, width: a.width);
    b = addInput('b', b, width: b.width);
    carry = addInput('carry_in', carry, width: carry.width);

    final n = a.width;
    FullAdder? res;

    assert(a.width == b.width, 'a and b should have same width.');

    for (var i = 0; i < n; i++) {
      res = FullAdder(a: a[i], b: b[i], carryIn: carry);

      carry = res.fullAdderRes.cOut;
      sum.add(res.fullAdderRes.sum);
    }

    sum.add(carry);
  }

  LogicValue get sumRes => sum.rswizzle().value;
}

void main() async {
  final a = Logic(name: 'a', width: 8);
  final b = Logic(name: 'b', width: 8);
  final nbitAdder = NBitAdder(a, b);

  await nbitAdder.build();

  // print(nbitAdder.generateSynth());

  test('should return 20 when A and B perform add.', () async {
    a.put(15);
    b.put(5);

    expect(nbitAdder.sumRes.toInt(), equals(20));
  });
}
```

Alright, that all for ROHD module. In next session we will be walk through Combinational Logic! Stay tuned!